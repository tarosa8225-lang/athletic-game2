<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FPS Athletic (Browser)</title>
  <style>
    html, body { height:100%; margin:0; background:#0b1020; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; }
    #hud {
      position: fixed; left: 12px; top: 10px;
      color: #e8eefc; font-size: 13px;
      background: rgba(255,255,255,.08);
      padding: 8px 10px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      user-select: none;
      backdrop-filter: blur(6px);
      line-height: 1.4;
      max-width: min(520px, calc(100vw - 24px));
    }
    #center {
      position: fixed; inset: 0; display:flex; align-items:center; justify-content:center;
      pointer-events: none;
    }
    #crosshair {
      width: 10px; height: 10px; border: 2px solid rgba(232,238,252,.9);
      border-radius: 999px; opacity: .9;
      box-shadow: 0 0 10px rgba(232,238,252,.25);
    }
    #overlay {
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(1200px 700px at 50% 30%, rgba(140,180,255,.22), rgba(0,0,0,.55));
      color: #e8eefc;
    }
    #panel {
      width: min(520px, calc(100vw - 28px));
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding: 16px 16px 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
    }
    #panel h1 { margin: 0 0 8px; font-size: 18px; }
    #panel p { margin: 8px 0; opacity: .92; }
    #panel kbd {
      padding: 2px 6px; border-radius: 6px;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.14);
      font-size: 12px;
    }
    #btn {
      margin-top: 10px;
      display:inline-flex; gap:10px; align-items:center;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.16);
      cursor: pointer;
      user-select: none;
      pointer-events: auto;
    }
    #btn:hover { background: rgba(255,255,255,.16); }
    #small { font-size: 12px; opacity: .82; margin-top: 10px; }
    #toast {
      position: fixed; right: 12px; top: 10px;
      color: #e8eefc; font-size: 13px;
      background: rgba(255,220,140,.16);
      border: 1px solid rgba(255,220,140,.26);
      padding: 8px 10px; border-radius: 12px;
      display:none;
      user-select:none;
    }
  </style>
</head>
<body>
  <div id="hud"></div>
  <div id="toast"></div>

  <div id="center"><div id="crosshair"></div></div>

  <div id="overlay">
    <div id="panel">
      <h1>FPS Athletic（3D一人称）</h1>
      <p>操作：<kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> 移動 / <kbd>Space</kbd> ジャンプ / <kbd>Shift</kbd> ダッシュ / <kbd>R</kbd> リスタート</p>
      <p>視点：開始後クリックでマウスロック（FPSみたいになる）</p>
      <div id="btn">▶ クリックして開始</div>
      <div id="small">※ ESCでマウスロック解除。落下 or トゲでチェックポイントに戻る。</div>
    </div>
  </div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js";

const hud = document.getElementById("hud");
const overlay = document.getElementById("overlay");
const btn = document.getElementById("btn");
const toast = document.getElementById("toast");

function showToast(msg, ms=1200){
  toast.textContent = msg;
  toast.style.display = "block";
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=> toast.style.display="none", ms);
}

// --- Renderer / Scene ---
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0b1020, 15, 120);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 500);
camera.position.set(0, 2, 8);

const controls = new PointerLockControls(camera, renderer.domElement);
scene.add(controls.getObject());

// Lights
scene.add(new THREE.HemisphereLight(0xbad7ff, 0x0b1020, 0.85));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(12, 18, 8);
scene.add(dir);

// Ground grid (visual)
const grid = new THREE.GridHelper(200, 200, 0x7aa5ff, 0x26406f);
grid.material.opacity = 0.18;
grid.material.transparent = true;
scene.add(grid);

// --- World building helpers ---
const world = {
  solids: [],   // { mesh, box3, kind: "solid" }
  hazards: [],  // { mesh, box3, kind: "hazard" }
  checkpoints: [], // { mesh, box3, spawn: Vector3, hit: bool }
  goal: null,   // { mesh, box3 }
  movers: [],   // moving platforms: { mesh, box3, basePos, axis, amp, spd, t, prevPos }
};

const matSolid = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.85, metalness: 0.0, transparent: true, opacity: 0.18 });
const matMover = new THREE.MeshStandardMaterial({ color: 0x7adcff, roughness: 0.6, metalness: 0.05, transparent: true, opacity: 0.22 });
const matHazard = new THREE.MeshStandardMaterial({ color: 0xff5a5a, roughness: 0.6, metalness: 0.0, transparent: true, opacity: 0.28 });
const matCheckpointOff = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8, metalness: 0.0, transparent: true, opacity: 0.35 });
const matCheckpointOn  = new THREE.MeshStandardMaterial({ color: 0x78ffa0, roughness: 0.6, metalness: 0.0, transparent: true, opacity: 0.9 });
const matGoal = new THREE.MeshStandardMaterial({ color: 0xffdc78, roughness: 0.65, metalness: 0.0, transparent: true, opacity: 0.26 });

function addBox({pos, size, mat, list, kind}){
  const geo = new THREE.BoxGeometry(size.x, size.y, size.z);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);

  const box3 = new THREE.Box3().setFromObject(mesh);
  const obj = { mesh, box3, kind };
  list.push(obj);
  return obj;
}

function updateBox3(obj){
  obj.box3.setFromObject(obj.mesh);
}

// --- Level layout ---
// Base platforms (solids)
addBox({ pos: new THREE.Vector3(0, -0.5, 0), size: new THREE.Vector3(20, 1, 20), mat: matSolid, list: world.solids, kind:"solid" });

// Course (a bit “parkour-ish”)
addBox({ pos: new THREE.Vector3(10, 0.6, -2), size: new THREE.Vector3(6, 1, 4), mat: matSolid, list: world.solids, kind:"solid" });
addBox({ pos: new THREE.Vector3(18, 1.8, -5), size: new THREE.Vector3(4, 1, 4), mat: matSolid, list: world.solids, kind:"solid" });
addBox({ pos: new THREE.Vector3(26, 3.0, -8), size: new THREE.Vector3(4, 1, 4), mat: matSolid, list: world.solids, kind:"solid" });
addBox({ pos: new THREE.Vector3(34, 4.2, -10), size: new THREE.Vector3(5, 1, 5), mat: matSolid, list: world.solids, kind:"solid" });

// Narrow beams
addBox({ pos: new THREE.Vector3(41, 5.1, -10), size: new THREE.Vector3(7, 0.6, 1.2), mat: matSolid, list: world.solids, kind:"solid" });
addBox({ pos: new THREE.Vector3(50, 6.0, -10), size: new THREE.Vector3(7, 0.6, 1.2), mat: matSolid, list: world.solids, kind:"solid" });

// Big landing
addBox({ pos: new THREE.Vector3(60, 5.2, -10), size: new THREE.Vector3(10, 1, 10), mat: matSolid, list: world.solids, kind:"solid" });

// Moving platforms (movers are also solids)
const mover1 = addBox({ pos: new THREE.Vector3(72, 5.0, -12), size: new THREE.Vector3(4.5, 0.7, 4.5), mat: matMover, list: world.solids, kind:"solid" });
world.movers.push({ obj: mover1, basePos: mover1.mesh.position.clone(), axis:"y", amp: 2.4, spd: 1.1, t: 0, prevPos: mover1.mesh.position.clone() });

const mover2 = addBox({ pos: new THREE.Vector3(82, 6.0, -12), size: new THREE.Vector3(6.0, 0.7, 3.0), mat: matMover, list: world.solids, kind:"solid" });
world.movers.push({ obj: mover2, basePos: mover2.mesh.position.clone(), axis:"x", amp: 3.2, spd: 0.9, t: 1.3, prevPos: mover2.mesh.position.clone() });

// Final climb
addBox({ pos: new THREE.Vector3(92, 7.4, -12), size: new THREE.Vector3(6, 1, 6), mat: matSolid, list: world.solids, kind:"solid" });
addBox({ pos: new THREE.Vector3(102, 9.2, -12), size: new THREE.Vector3(5, 1, 5), mat: matSolid, list: world.solids, kind:"solid" });

// Hazards (spikes = red boxes)
addBox({ pos: new THREE.Vector3(18, 1.0, -2), size: new THREE.Vector3(3.2, 0.25, 3.2), mat: matHazard, list: world.hazards, kind:"hazard" });
addBox({ pos: new THREE.Vector3(41, 4.85, -8), size: new THREE.Vector3(3.2, 0.25, 3.2), mat: matHazard, list: world.hazards, kind:"hazard" });
addBox({ pos: new THREE.Vector3(64, 4.7, -12), size: new THREE.Vector3(3.0, 0.25, 3.0), mat: matHazard, list: world.hazards, kind:"hazard" });

// Checkpoints
function addCheckpoint(pos){
  const cp = addBox({ pos, size: new THREE.Vector3(0.35, 2.2, 0.35), mat: matCheckpointOff, list: world.checkpoints, kind:"checkpoint" });
  cp.hit = false;
  cp.spawn = pos.clone().add(new THREE.Vector3(0, 1.2, 1.4));
  return cp;
}
addCheckpoint(new THREE.Vector3(10, 2.0, 3));
addCheckpoint(new THREE.Vector3(60, 7.0, -6));
addCheckpoint(new THREE.Vector3(92, 10.0, -8));

// Goal
world.goal = addBox({ pos: new THREE.Vector3(112, 10.0, -12), size: new THREE.Vector3(4, 3, 4), mat: matGoal, list: [], kind:"goal" });

// Some walls (just to guide)
addBox({ pos: new THREE.Vector3(30, 2.0, 6), size: new THREE.Vector3(90, 6, 1.2), mat: matSolid, list: world.solids, kind:"solid" });
addBox({ pos: new THREE.Vector3(30, 2.0, -24), size: new THREE.Vector3(90, 6, 1.2), mat: matSolid, list: world.solids, kind:"solid" });

// --- Player physics ---
const PLAYER = {
  height: 1.75,
  radius: 0.35,
  // For collision we use an AABB centered around player (camera is at head height)
  aabbHalf: new THREE.Vector3(0.35, 0.95, 0.35),
  eyeOffset: new THREE.Vector3(0, 0.75, 0),
};
let velocity = new THREE.Vector3(0,0,0);
let onGround = false;
let deaths = 0;
let finished = false;
let startTime = performance.now();
let finishTime = 0;

const spawnDefault = new THREE.Vector3(0, 1.2, 8);
let currentSpawn = spawnDefault.clone();

// Movement tuning
const GRAVITY = 18.5;
const WALK_SPEED = 6.2;
const RUN_SPEED  = 9.2;
const AIR_CONTROL = 0.45;
const JUMP_V = 7.6;
const FRICTION = 12.0;

// Input
const keys = new Set();
window.addEventListener("keydown", (e) => {
  keys.add(e.code);
  if (e.code === "KeyR") restartRun(true);
});
window.addEventListener("keyup", (e) => keys.delete(e.code));

function wantForward(){ return keys.has("KeyW"); }
function wantBack(){ return keys.has("KeyS"); }
function wantLeft(){ return keys.has("KeyA"); }
function wantRight(){ return keys.has("KeyD"); }
function wantJump(){ return keys.has("Space"); }
function wantRun(){ return keys.has("ShiftLeft") || keys.has("ShiftRight"); }

// Pointer lock start
btn.addEventListener("click", () => controls.lock());
controls.addEventListener("lock", () => {
  overlay.style.display = "none";
});
controls.addEventListener("unlock", () => {
  overlay.style.display = "flex";
});

// Helpers
function playerPos(){ return controls.getObject().position; }

// AABB for player based on body center (not eye)
function playerAABB(pos){
  // body center is eye position minus eyeOffset
  const center = pos.clone().sub(PLAYER.eyeOffset);
  return new THREE.Box3(
    center.clone().sub(PLAYER.aabbHalf),
    center.clone().add(PLAYER.aabbHalf)
  );
}

// Resolve AABB penetration against solid box
function resolveAABBAgainstBox(pBox, sBox, pos){
  if (!pBox.intersectsBox(sBox)) return { moved:false, pos };

  const pMin = pBox.min, pMax = pBox.max;
  const sMin = sBox.min, sMax = sBox.max;

  const overlapX = Math.min(pMax.x - sMin.x, sMax.x - pMin.x);
  const overlapY = Math.min(pMax.y - sMin.y, sMax.y - pMin.y);
  const overlapZ = Math.min(pMax.z - sMin.z, sMax.z - pMin.z);

  // push out along smallest overlap axis
  let moved = false;
  const newPos = pos.clone();

  if (overlapX <= overlapY && overlapX <= overlapZ) {
    // push x
    const pCenterX = (pMin.x + pMax.x) * 0.5;
    const sCenterX = (sMin.x + sMax.x) * 0.5;
    const dir = pCenterX < sCenterX ? -1 : 1;
    newPos.x += dir * overlapX;
    velocity.x = 0;
    moved = true;
  } else if (overlapY <= overlapX && overlapY <= overlapZ) {
    // push y
    const pCenterY = (pMin.y + pMax.y) * 0.5;
    const sCenterY = (sMin.y + sMax.y) * 0.5;
    const dir = pCenterY < sCenterY ? -1 : 1;
    newPos.y += dir * overlapY;
    if (dir < 0) { // pushed up (standing on top)
      velocity.y = Math.max(0, velocity.y);
      onGround = true;
    } else {
      velocity.y = Math.min(0, velocity.y);
    }
    moved = true;
  } else {
    // push z
    const pCenterZ = (pMin.z + pMax.z) * 0.5;
    const sCenterZ = (sMin.z + sMax.z) * 0.5;
    const dir = pCenterZ < sCenterZ ? -1 : 1;
    newPos.z += dir * overlapZ;
    velocity.z = 0;
    moved = true;
  }

  return { moved, pos: newPos };
}

function setSpawn(v3){
  currentSpawn.copy(v3);
}

function restartRun(keepDeaths=false){
  if (!keepDeaths) deaths = 0;
  finished = false;
  startTime = performance.now();
  finishTime = 0;
  // reset checkpoints
  for (const cp of world.checkpoints){
    cp.hit = false;
    cp.mesh.material = matCheckpointOff;
  }
  setSpawn(spawnDefault);
  respawn(false);
  showToast("リスタート！");
}

function respawn(countDeath=true){
  if (countDeath) deaths++;
  velocity.set(0,0,0);
  onGround = false;
  const p = playerPos();
  p.copy(currentSpawn);
}

function markCheckpoint(cp){
  cp.hit = true;
  cp.mesh.material = matCheckpointOn;
  setSpawn(cp.spawn);
  showToast("チェックポイント更新");
}

// Start at spawn
playerPos().copy(spawnDefault);

// --- Animate ---
let last = performance.now();

function updateMovers(dt){
  for (const m of world.movers){
    m.prevPos.copy(m.obj.mesh.position);
    m.t += dt * m.spd;
    const p = m.basePos.clone();
    const s = Math.sin(m.t) * m.amp;
    if (m.axis === "y") p.y += s;
    if (m.axis === "x") p.x += s;
    if (m.axis === "z") p.z += s;
    m.obj.mesh.position.copy(p);
    updateBox3(m.obj);

    // If standing on mover, carry player by delta (simple)
    // We'll detect "standing" by: onGround + player just above mover
  }
}

function step(dt){
  // update boxes (solids static are fine; movers updated separately)
  updateMovers(dt);

  if (finished){
    // still render, no movement
    return;
  }

  onGround = false;

  // Movement direction based on camera yaw
  const dirF = new THREE.Vector3();
  camera.getWorldDirection(dirF);
  dirF.y = 0; dirF.normalize();
  const dirR = new THREE.Vector3().crossVectors(dirF, new THREE.Vector3(0,1,0)).normalize().multiplyScalar(-1);

  let wish = new THREE.Vector3();
  if (wantForward()) wish.add(dirF);
  if (wantBack()) wish.sub(dirF);
  if (wantRight()) wish.add(dirR);
  if (wantLeft()) wish.sub(dirR);
  if (wish.lengthSq() > 0) wish.normalize();

  const speed = wantRun() ? RUN_SPEED : WALK_SPEED;
  const targetV = wish.multiplyScalar(speed);

  // Apply accel: ground snappy / air limited
  const accel = onGround ? 16.0 : 10.0;
  const control = onGround ? 1.0 : AIR_CONTROL;

  // We'll apply control to horizontal components
  velocity.x += (targetV.x - velocity.x) * Math.min(1, accel * dt * control);
  velocity.z += (targetV.z - velocity.z) * Math.min(1, accel * dt * control);

  // Friction when no input & on ground (we'll approximate using low-speed damping)
  if (wish.lengthSq() === 0 && onGround){
    const damp = Math.exp(-FRICTION * dt);
    velocity.x *= damp;
    velocity.z *= damp;
  }

  // Gravity
  velocity.y -= GRAVITY * dt;

  // Jump (simple edge trigger)
  if (wantJump() && onGround){
    velocity.y = JUMP_V;
    onGround = false;
  }

  // Integrate
  const p = playerPos();
  const prev = p.clone();
  p.addScaledVector(velocity, dt);

  // Collision resolution (iterate a couple times)
  for (let iter=0; iter<3; iter++){
    const pBox = playerAABB(p);
    let movedAny = false;

    // Solve against solids
    for (const s of world.solids){
      // ensure mover boxes are updated; static boxes were set at creation
      const res = resolveAABBAgainstBox(pBox, s.box3, p);
      if (res.moved){
        p.copy(res.pos);
        movedAny = true;
      }
    }
    if (!movedAny) break;
  }

  // After resolving, determine onGround by a tiny probe down
  {
    const probePos = p.clone();
    probePos.y -= 0.03;
    const probe = playerAABB(probePos);
    for (const s of world.solids){
      if (probe.intersectsBox(s.box3)){
        onGround = true;
        break;
      }
    }
    if (onGround && velocity.y < 0) velocity.y = 0;
  }

  // Carry by movers if standing on them (detect overlap slightly below)
  if (onGround){
    const below = p.clone(); below.y -= 0.04;
    const pBelow = playerAABB(below);
    for (const m of world.movers){
      if (pBelow.intersectsBox(m.obj.box3)){
        const delta = m.obj.mesh.position.clone().sub(m.prevPos);
        p.add(delta);
        break;
      }
    }
  }

  // Hazards (death)
  const pBoxNow = playerAABB(p);
  for (const hz of world.hazards){
    if (pBoxNow.intersectsBox(hz.box3)){
      respawn(true);
      showToast("トゲ！戻された");
      return;
    }
  }

  // Checkpoints
  for (const cp of world.checkpoints){
    updateBox3(cp); // safe
    if (!cp.hit && pBoxNow.intersectsBox(cp.box3)){
      markCheckpoint(cp);
    }
  }

  // Goal
  updateBox3(world.goal);
  if (pBoxNow.intersectsBox(world.goal.box3)){
    finished = true;
    finishTime = (performance.now() - startTime) / 1000;
    showToast(`CLEAR! ${finishTime.toFixed(2)}s`, 2200);
  }

  // Fall death
  if (p.y < -25){
    respawn(true);
    showToast("落下！戻された");
  }
}

function render(){
  renderer.render(scene, camera);
}

function loop(now){
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;

  if (controls.isLocked) step(dt);

  // HUD
  const t = finished ? finishTime : (now - startTime) / 1000;
  hud.innerHTML =
    `Time <b>${t.toFixed(2)}</b>　|　Death <b>${deaths}</b>` +
    (finished ? `　|　✅ CLEAR! <span style="opacity:.9">（Rでリスタート）</span>` : "") +
    `<br><span style="opacity:.85">WASD移動 / Spaceジャンプ / Shiftダッシュ / Rリスタート / ESC解除</span>`;

  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

window.addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Make sure static solids have box3 ready
for (const s of world.solids) updateBox3(s);
for (const h of world.hazards) updateBox3(h);
for (const cp of world.checkpoints) updateBox3(cp);
updateBox3(world.goal);

</script>
</body>
</html>
