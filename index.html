<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini 3D FPS (Three.js) - Full Prototype</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#070a10; }
    canvas { display:block; }
    .hud {
      position:fixed; inset:0; pointer-events:none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
      color:#eaf2ff;
    }
    .tl { position:absolute; left:14px; top:12px; font-size:14px; opacity:0.95; }
    .tl .s { opacity:0.75; font-size:12px; margin-top:6px; line-height:1.45; }
    .tr { position:absolute; right:14px; top:12px; font-size:14px; text-align:right; opacity:0.95; }
    .br { position:absolute; right:14px; bottom:12px; font-size:14px; text-align:right; opacity:0.95; }
    .center { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); }
    .cross {
      width: 18px; height: 18px; position: relative;
      filter: drop-shadow(0 0 2px rgba(0,0,0,0.9));
      opacity:0.9;
    }
    .cross:before, .cross:after{
      content:""; position:absolute; left:50%; top:50%;
      background:#eaf2ff; transform:translate(-50%,-50%);
    }
    .cross:before{ width:18px; height:2px; }
    .cross:after{ width:2px; height:18px; }
    .hint {
      position:absolute; left:50%; top:62%;
      transform:translate(-50%,-50%);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px 12px; border-radius: 10px;
      font-size: 14px; line-height:1.45; text-align:center;
      max-width: 720px;
    }
    .bar {
      height: 8px; width: 260px; background: rgba(255,255,255,0.10);
      border-radius: 999px; overflow:hidden; border:1px solid rgba(255,255,255,0.10);
      margin-top:6px;
    }
    .bar > div { height:100%; width:100%; background: rgba(110,200,255,0.95); }
    .small { font-size: 12px; opacity:0.8; }
    kbd{
      padding: 1px 6px; border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="tl">
      <div><b>Mini 3D FPS</b> (Three.js) — 全部入り</div>
      <div class="s">
        クリックで開始（PointerLock）/ <kbd>ESC</kbd>解除<br/>
        <kbd>WASD</kbd>移動　<kbd>Shift</kbd>走る　<kbd>Space</kbd>ジャンプ<br/>
        <kbd>Ctrl</kbd>スライディング（走り中）　左クリック射撃　右クリックADS<br/>
        <kbd>R</kbd>リロード　<kbd>1</kbd>/<kbd>2</kbd>武器切替（SMG/SG）
      </div>
    </div>
    <div class="tr">
      <div id="weapon"></div>
      <div id="ammo"></div>
      <div class="small" id="status"></div>
    </div>
    <div class="center">
      <div class="cross"></div>
      <div class="hint" id="hint">
        画面を<b>クリック</b>して開始（上下視点OK）<br/>
        建物を遮蔽にして敵（人形）を撃ってね
      </div>
    </div>
    <div class="br">
      <div>HP</div>
      <div class="bar"><div id="hpbar"></div></div>
      <div class="small" id="debug"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ===== UI =====
    const weaponEl = document.getElementById("weapon");
    const ammoEl = document.getElementById("ammo");
    const statusEl = document.getElementById("status");
    const hpbarEl = document.getElementById("hpbar");
    const hintEl = document.getElementById("hint");
    const debugEl = document.getElementById("debug");

    // ===== Renderer/Scene/Camera =====
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x070a10, 30, 140);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 400);
    const yawObj = new THREE.Object3D();
    const pitchObj = new THREE.Object3D();
    yawObj.add(pitchObj);
    pitchObj.add(camera);
    scene.add(yawObj);

    // Base camera height & crouch/slide camera offset
    const CAM_STAND_Y = 1.6;
    const CAM_SLIDE_Y = 1.05;

    yawObj.position.set(0, CAM_STAND_Y, 10);
    camera.position.set(0, 0, 0);

    // ===== Lights =====
    scene.add(new THREE.HemisphereLight(0x9bbcff, 0x0b0f16, 0.7));
    const sun = new THREE.DirectionalLight(0xffffff, 1.1);
    sun.position.set(18, 28, 10);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.near = 1;
    sun.shadow.camera.far = 160;
    sun.shadow.camera.left = -70;
    sun.shadow.camera.right = 70;
    sun.shadow.camera.top = 70;
    sun.shadow.camera.bottom = -70;
    scene.add(sun);

    // ===== Materials =====
    const matGround = new THREE.MeshStandardMaterial({ color: 0x0c121a, roughness: 1.0, metalness: 0.0 });
    const matWall   = new THREE.MeshStandardMaterial({ color: 0x1b2635, roughness: 0.9, metalness: 0.05 });
    const matAccent = new THREE.MeshStandardMaterial({ color: 0x2e4766, roughness: 0.8, metalness: 0.1 });
    const rockMat   = new THREE.MeshStandardMaterial({ color: 0x141b25, roughness: 1.0, metalness: 0.0 });

    // ===== Colliders + Obstacle meshes (for bullet blocking) =====
    const colliders = [];      // { box: THREE.Box3, mesh: Mesh, tag: string }
    const obstacleMeshes = []; // meshes that can block bullets

    function addColliderFromMesh(mesh, tag="") {
      const box = new THREE.Box3().setFromObject(mesh);
      colliders.push({ box, mesh, tag });
      obstacleMeshes.push(mesh);
    }

    // ===== World =====
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(260, 260), matGround);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    function addBox(x,z,w,d,h=6, mat=matWall, tag="") {
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
      mesh.position.set(x, h/2, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);
      addColliderFromMesh(mesh, tag);
      return mesh;
    }

    function addBuilding(x,z,w,d,h) {
      const mesh = addBox(x,z,w,d,h,matWall,"building");
      const band = new THREE.Mesh(new THREE.BoxGeometry(w*1.01, 0.4, d*1.01), matAccent);
      band.position.set(0, h*0.55, 0);
      band.receiveShadow = true;
      mesh.add(band);
      return mesh;
    }

    function addCrate(x,z,s=1.1) {
      return addBox(x,z,s,s,s,matAccent,"crate");
    }

    function addRock(x,z,r=1.4) {
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(r, 18, 14), rockMat);
      mesh.position.set(x, r*0.9, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);
      addColliderFromMesh(mesh, "rock");
      return mesh;
    }

    // Boundary walls
    addBox(0, -130, 260, 2, 10, matWall, "wall");
    addBox(0,  130, 260, 2, 10, matWall, "wall");
    addBox(-130, 0, 2, 260, 10, matWall, "wall");
    addBox( 130, 0, 2, 260, 10, matWall, "wall");

    // Buildings / props layout
    addBuilding(-30,  15, 18, 14, 10);
    addBuilding(-10,  25, 10, 10, 7);
    addBuilding( 18,  18, 16, 12, 9);
    addBuilding( 40,  10, 14, 18, 11);
    addBuilding( 35, -22, 18, 14, 8);
    addBuilding(  5, -25, 20, 12, 9);
    addBuilding(-25, -25, 14, 18, 12);
    addBuilding(-50, -10, 16, 12, 8);
    addBuilding( 60,  40, 18, 12, 9);
    addBuilding( 75, -35, 16, 16, 12);

    for (let i=0;i<12;i++) addCrate(-5 + i*3.5, -5, 1.0);
    for (let i=0;i<10;i++) addCrate(22, -40 + i*3.2, 1.2);
    for (let i=0;i<14;i++) addCrate(-80 + i*3.2, 55, 1.05);

    addRock(-60, 40, 2.2);
    addRock(-72, 52, 1.6);
    addRock(70, -60, 2.6);
    addRock(62, -72, 1.8);
    addRock(95, 70, 2.2);

    // ===== Input =====
    const keys = new Set();
    addEventListener("keydown", (e) => {
      keys.add(e.code);
      if (e.code === "KeyR") startReload();
      if (e.code === "Digit1") equip("SMG");
      if (e.code === "Digit2") equip("SG");
    });
    addEventListener("keyup", (e) => keys.delete(e.code));

    let leftDown = false;
    let rightDown = false;
    addEventListener("mousedown", (e)=>{ if(e.button===0) leftDown=true; if(e.button===2) rightDown=true; });
    addEventListener("mouseup",   (e)=>{ if(e.button===0) leftDown=false; if(e.button===2) rightDown=false; });
    addEventListener("contextmenu", (e)=> e.preventDefault());

    // Pointer Lock
    const canvas = renderer.domElement;
    canvas.addEventListener("click", () => canvas.requestPointerLock?.());
    document.addEventListener("pointerlockchange", () => {
      hintEl.style.display = (document.pointerLockElement === canvas) ? "none" : "block";
    });

    // ===== Look (Yaw + Pitch + recoil) =====
    let yaw = 0;
    let pitch = 0;
    const pitchMin = -Math.PI/2 + 0.12;
    const pitchMax =  Math.PI/2 - 0.12;

    const baseMouseSens = 0.0022;
    const adsMouseMul = 0.62;

    // Recoil state
    let recoilPitch = 0; // added on top of pitch
    let recoilYaw = 0;
    const recoilReturn = 14.0; // how fast recoil returns per sec

    document.addEventListener("mousemove", (e) => {
      if (document.pointerLockElement !== canvas) return;

      const sens = baseMouseSens * (rightDown ? adsMouseMul : 1);
      yaw   -= e.movementX * sens;
      pitch -= e.movementY * sens; // Y軸視点（上下）
      pitch = Math.max(pitchMin, Math.min(pitchMax, pitch));

      yawObj.rotation.y = yaw + recoilYaw;
      pitchObj.rotation.x = (pitch + recoilPitch);
    });

    // ===== Player Physics =====
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

    const player = {
      pos: new THREE.Vector3(0, CAM_STAND_Y, 10),
      vel: new THREE.Vector3(0, 0, 0),
      radius: 0.45,
      speed: 6.2,
      sprintMul: 1.45,
      jumpVel: 7.0,
      gravity: 20,
      hp: 100,
      maxHp: 100,
      onGround: false,

      // Sliding
      sliding: false,
      slideTime: 0,
      slideDur: 0.75,
      slideSpeed: 11.0,
      slideDir: new THREE.Vector3(),
    };

    function syncCamera() {
      yawObj.position.set(player.pos.x, player.pos.y, player.pos.z);
    }

    function refreshColliders() {
      for (const c of colliders) c.box.setFromObject(c.mesh);
    }

    function resolveSphereAABB(center, radius, box) {
      const cx = clamp(center.x, box.min.x, box.max.x);
      const cy = clamp(center.y, box.min.y, box.max.y);
      const cz = clamp(center.z, box.min.z, box.max.z);
      const dx = center.x - cx, dy = center.y - cy, dz = center.z - cz;
      const dist2 = dx*dx + dy*dy + dz*dz;
      if (dist2 >= radius*radius) return null;
      const dist = Math.sqrt(Math.max(1e-8, dist2));
      const pen = radius - dist;
      return { nx: dx/dist, ny: dy/dist, nz: dz/dist, penetration: pen };
    }

    function startSlide() {
      if (player.sliding) return;
      if (!player.onGround) return;
      const sprinting = keys.has("ShiftLeft") || keys.has("ShiftRight");
      if (!sprinting) return;

      player.sliding = true;
      player.slideTime = 0;

      // slide direction = forward (based on yaw)
      player.slideDir.set(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw).normalize();
      // small burst from current velocity + forward
      const boost = player.slideSpeed;
      player.vel.x = player.slideDir.x * boost;
      player.vel.z = player.slideDir.z * boost;

      // lower camera
      player.pos.y = CAM_SLIDE_Y;
    }

    function endSlide() {
      if (!player.sliding) return;
      player.sliding = false;
      player.pos.y = CAM_STAND_Y;
    }

    function getMoveVector() {
      let x = 0, z = 0;
      if (keys.has("KeyW")) z -= 1;
      if (keys.has("KeyS")) z += 1;
      if (keys.has("KeyA")) x -= 1;
      if (keys.has("KeyD")) x += 1;

      const v = new THREE.Vector3(x, 0, z);
      if (v.lengthSq() > 0) v.normalize();

      const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
      const right   = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);

      const move = new THREE.Vector3()
        .addScaledVector(right, v.x)
        .addScaledVector(forward, v.z);

      if (move.lengthSq() > 0) move.normalize();
      return move;
    }

    function updatePlayer(dt) {
      if (document.pointerLockElement !== canvas) return;

      // Slide trigger
      if ((keys.has("ControlLeft") || keys.has("ControlRight")) && !player.sliding) {
        startSlide();
      }

      // Horizontal movement
      if (!player.sliding) {
        const moveDir = getMoveVector();
        const sprinting = keys.has("ShiftLeft") || keys.has("ShiftRight");
        const sp = player.speed * (sprinting ? player.sprintMul : 1);

        const desired = new THREE.Vector3().copy(moveDir).multiplyScalar(sp);

        // accel
        player.vel.x = THREE.MathUtils.lerp(player.vel.x, desired.x, 0.18);
        player.vel.z = THREE.MathUtils.lerp(player.vel.z, desired.z, 0.18);

        // camera height ensure standing
        player.pos.y = CAM_STAND_Y;
      } else {
        player.slideTime += dt;

        // friction / decay
        const decay = Math.exp(-dt * 2.4);
        player.vel.x *= decay;
        player.vel.z *= decay;

        // end slide
        if (player.slideTime >= player.slideDur || (!keys.has("ControlLeft") && !keys.has("ControlRight"))) {
          endSlide();
        } else {
          // keep low camera while sliding
          player.pos.y = CAM_SLIDE_Y;
        }
      }

      // Gravity
      player.vel.y -= player.gravity * dt;

      // Jump (disable during slide)
      if (!player.sliding && player.onGround && keys.has("Space")) {
        player.vel.y = player.jumpVel;
        player.onGround = false;
      }

      // Integrate
      const nextPos = player.pos.clone().addScaledVector(player.vel, dt);

      // Ground plane: treat as flat ground with camera height
      const targetStandY = player.sliding ? CAM_SLIDE_Y : CAM_STAND_Y;
      if (nextPos.y <= targetStandY) {
        nextPos.y = targetStandY;
        player.vel.y = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }

      // Collision sphere around lower body
      const sphereCenter = new THREE.Vector3(nextPos.x, 1.0, nextPos.z);

      refreshColliders();

      for (let iter=0; iter<3; iter++) {
        let pushed = false;
        for (const c of colliders) {
          const res = resolveSphereAABB(sphereCenter, player.radius, c.box);
          if (!res) continue;
          sphereCenter.x += res.nx * res.penetration;
          sphereCenter.y += res.ny * res.penetration;
          sphereCenter.z += res.nz * res.penetration;
          pushed = true;
        }
        if (!pushed) break;
      }

      nextPos.x = sphereCenter.x;
      nextPos.z = sphereCenter.z;

      // Damp if stuck
      const dx = nextPos.x - player.pos.x;
      const dz = nextPos.z - player.pos.z;
      if (Math.abs(dx) < 1e-4) player.vel.x *= 0.35;
      if (Math.abs(dz) < 1e-4) player.vel.z *= 0.35;

      player.pos.copy(nextPos);
      syncCamera();
    }

    // ===== Enemies (humanoid dolls) =====
    const enemies = [];
    const enemyGroup = new THREE.Group();
    scene.add(enemyGroup);

    function makeHumanoid(color=0xff7a7a) {
      const g = new THREE.Group();
      const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.85, metalness: 0.05 });

      const head = new THREE.Mesh(new THREE.SphereGeometry(0.22, 18, 14), bodyMat);
      head.position.y = 1.62;
      head.castShadow = true;

      const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.25, 0.6, 10, 16), bodyMat);
      torso.position.y = 1.10;
      torso.castShadow = true;

      const armGeo = new THREE.CapsuleGeometry(0.10, 0.45, 8, 12);
      const armL = new THREE.Mesh(armGeo, bodyMat);
      const armR = new THREE.Mesh(armGeo, bodyMat);
      armL.position.set(-0.38, 1.15, 0);
      armR.position.set( 0.38, 1.15, 0);
      armL.rotation.z = 0.2;
      armR.rotation.z = -0.2;
      armL.castShadow = armR.castShadow = true;

      const legGeo = new THREE.CapsuleGeometry(0.11, 0.55, 8, 12);
      const legL = new THREE.Mesh(legGeo, bodyMat);
      const legR = new THREE.Mesh(legGeo, bodyMat);
      legL.position.set(-0.16, 0.55, 0);
      legR.position.set( 0.16, 0.55, 0);
      legL.castShadow = legR.castShadow = true;

      g.add(head, torso, armL, armR, legL, legR);
      const hitMeshes = [head, torso, armL, armR, legL, legR];
      return { group: g, hitMeshes, headMesh: head };
    }

    function spawnEnemy(x,z) {
      const { group, hitMeshes, headMesh } = makeHumanoid(0xff7a7a);
      group.position.set(x, 0, z);
      group.traverse(o => { if (o.isMesh) o.receiveShadow = true; });
      enemyGroup.add(group);

      const enemy = {
        group,
        hitMeshes,
        headMesh,
        hp: 140,
        maxHp: 140,
        speed: 2.1,
        alive: true,
      };

      for (const m of hitMeshes) m.userData.enemyRef = enemy;
      enemies.push(enemy);
      return enemy;
    }

    spawnEnemy( 10,  40);
    spawnEnemy(-15,  55);
    spawnEnemy( 48, -10);
    spawnEnemy(-55, -18);
    spawnEnemy(  5, -55);
    spawnEnemy(-35,  10);
    spawnEnemy( 85,  5);

    function updateEnemies(dt) {
      for (const e of enemies) {
        if (!e.alive) continue;

        const ep = e.group.position;
        const toP = new THREE.Vector3(player.pos.x - ep.x, 0, player.pos.z - ep.z);
        const d = toP.length();

        if (d > 0.001) {
          toP.normalize();
          ep.x += toP.x * e.speed * dt;
          ep.z += toP.z * e.speed * dt;
          e.group.rotation.y = Math.atan2(player.pos.x - ep.x, player.pos.z - ep.z);
        }

        if (d < 1.4) {
          player.hp -= 18 * dt;
          player.hp = Math.max(0, player.hp);
        }

        const t = performance.now() * 0.004;
        e.group.position.y = Math.sin(t + ep.x*0.1 + ep.z*0.1) * 0.03;
      }
    }

    // ===== Weapons =====
    const raycaster = new THREE.Raycaster();

    const weapons = {
      SMG: {
        name: "SMG",
        magSize: 28,
        ammo: 28,
        reloadTime: 1.05,
        fireRate: 12.0,
        damage: 18,
        range: 140,
        spreadHip: 0.010,
        spreadAds: 0.004,
        recoilPitch: 0.010,
        recoilYaw: 0.004,
        pellets: 1,
      },
      SG: {
        name: "Shotgun",
        magSize: 6,
        ammo: 6,
        reloadTime: 1.25,
        fireRate: 1.3,
        damage: 11,      // per pellet
        range: 55,
        spreadHip: 0.055,
        spreadAds: 0.030,
        recoilPitch: 0.030,
        recoilYaw: 0.010,
        pellets: 10,
      }
    };

    let currentWeapon = weapons.SMG;

    function equip(key) {
      const w = weapons[key];
      if (!w) return;
      currentWeapon = w;
      statusEl.textContent = "";
    }

    // ===== Reload =====
    let reloading = false;
    function startReload() {
      if (reloading) return;
      if (currentWeapon.ammo === currentWeapon.magSize) return;

      reloading = true;
      statusEl.textContent = "Reloading...";
      setTimeout(() => {
        currentWeapon.ammo = currentWeapon.magSize;
        reloading = false;
        statusEl.textContent = "";
      }, currentWeapon.reloadTime * 1000);
    }

    // ===== Bullet + Wall blocking + Enemy hit =====
    function applyRecoil() {
      // add immediate kick
      const w = currentWeapon;
      const adsMul = rightDown ? 0.65 : 1.0;
      recoilPitch += w.recoilPitch * adsMul;
      recoilYaw   += (Math.random()*2 - 1) * w.recoilYaw * adsMul;

      // clamp recoil so it doesn't explode
      recoilPitch = clamp(recoilPitch, -0.25, 0.25);
      recoilYaw   = clamp(recoilYaw, -0.25, 0.25);

      // apply to objects now
      yawObj.rotation.y = yaw + recoilYaw;
      pitchObj.rotation.x = clamp(pitch + recoilPitch, pitchMin, pitchMax);
    }

    function getShotSpread() {
      const w = currentWeapon;
      return rightDown ? w.spreadAds : w.spreadHip;
    }

    function raycastOnePellet(origin, baseDir, range, spread) {
      // random cone spread by jittering direction
      const dir = baseDir.clone();
      dir.x += (Math.random()*2 - 1) * spread;
      dir.y += (Math.random()*2 - 1) * spread;
      dir.z += (Math.random()*2 - 1) * spread;
      dir.normalize();

      raycaster.set(origin, dir);
      raycaster.far = range;

      // We want nearest of (obstacles + enemies)
      // Intersect everything, then pick nearest and process.
      const hits = raycaster.intersectObjects([...obstacleMeshes, ...enemyGroup.children], true);
      return hits[0] || null;
    }

    function tryShoot(timeNow) {
      if (document.pointerLockElement !== canvas) return;
      if (!leftDown) return;
      if (reloading) return;
      if (player.hp <= 0) return;

      const w = currentWeapon;
      if (timeNow - (w._lastShot || 0) < 1 / w.fireRate) return;

      if (w.ammo <= 0) {
        startReload();
        return;
      }

      w._lastShot = timeNow;
      w.ammo--;

      const origin = new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld);
      const baseDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
      const spread = getShotSpread();

      applyRecoil();

      // Shoot pellets
      for (let i=0; i<w.pellets; i++) {
        const hit = raycastOnePellet(origin, baseDir, w.range, spread);
        if (!hit) continue;

        // If obstacle hit first => blocked
        // If enemy hit first => damage
        const obj = hit.object;
        const enemy = obj?.userData?.enemyRef;

        if (enemy && enemy.alive) {
          // headshot bonus if the mesh is head mesh
          let dmg = w.damage;
          if (obj === enemy.headMesh) dmg = Math.floor(dmg * 1.8);

          enemy.hp -= dmg;

          if (enemy.hp <= 0) {
            enemy.alive = false;
            enemyGroup.remove(enemy.group);

            // respawn later somewhere in front-ish
            setTimeout(() => {
              const a = yaw + (Math.random()*1.4 - 0.7);
              const d = 25 + Math.random()*70;
              spawnEnemy(player.pos.x + Math.cos(a)*d, player.pos.z + Math.sin(a)*d);
            }, 700);
          }
        } else {
          // hit wall/prop: nothing else (blocked)
        }
      }
    }

    // ===== ADS (FOV change) =====
    const baseFov = 75;
    const adsFov = 58;
    function updateCameraFov(dt) {
      const target = rightDown ? adsFov : baseFov;
      camera.fov = THREE.MathUtils.lerp(camera.fov, target, 1 - Math.exp(-dt * 14));
      camera.updateProjectionMatrix();
    }

    // ===== Recoil return =====
    function updateRecoil(dt) {
      // smoothly return recoil to 0
      const k = 1 - Math.exp(-dt * recoilReturn);
      recoilPitch = THREE.MathUtils.lerp(recoilPitch, 0, k);
      recoilYaw   = THREE.MathUtils.lerp(recoilYaw, 0, k);
      yawObj.rotation.y = yaw + recoilYaw;
      pitchObj.rotation.x = clamp(pitch + recoilPitch, pitchMin, pitchMax);
    }

    // ===== UI =====
    function updateUI() {
      weaponEl.textContent = `Weapon: ${currentWeapon.name} (1/2)`;
      ammoEl.textContent = `Ammo: ${currentWeapon.ammo}/${currentWeapon.magSize}`;
      hpbarEl.style.width = `${(player.hp/player.maxHp)*100}%`;

      const locked = (document.pointerLockElement === canvas);
      if (!locked) statusEl.textContent = "クリックで開始（ESCで解除）";
      else if (reloading) statusEl.textContent = "Reloading...";
      else statusEl.textContent = "";

      const aliveEnemies = enemies.filter(e=>e.alive).length;
      debugEl.textContent = `Enemies: ${aliveEnemies} / Sliding: ${player.sliding ? "Yes" : "No"} / ADS: ${rightDown ? "Yes" : "No"}`;

      if (player.hp <= 0) statusEl.textContent = "Down…（F5でリスタート）";
    }

    // ===== Resize =====
    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ===== Main Loop =====
    const clock = new THREE.Clock();

    function animate() {
      const dt = Math.min(0.033, clock.getDelta());
      const t = performance.now() / 1000;

      if (player.hp > 0) {
        updatePlayer(dt);
        updateEnemies(dt);
        tryShoot(t);
      }

      updateRecoil(dt);
      updateCameraFov(dt);
      updateUI();

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // init
    syncCamera();
    equip("SMG");
    animate();
  </script>
</body>
</html>
