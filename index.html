<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FPS Athletic</title>
  <style>
    html, body { height:100%; margin:0; background:#0b1020; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; }
    #hud {
      position: fixed; left: 12px; top: 10px;
      color: #e8eefc; font-size: 13px;
      background: rgba(255,255,255,.08);
      padding: 8px 10px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      user-select: none;
      backdrop-filter: blur(6px);
      line-height: 1.45;
      max-width: min(720px, calc(100vw - 24px));
      z-index: 5;
      white-space: nowrap;
    }
    #center { position: fixed; inset: 0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index: 4; }
    #crosshair { width: 10px; height: 10px; border: 2px solid rgba(232,238,252,.9); border-radius: 999px; opacity: .9; box-shadow: 0 0 10px rgba(232,238,252,.25); }
    #overlay {
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(1200px 700px at 50% 30%, rgba(140,180,255,.22), rgba(0,0,0,.55));
      color: #e8eefc;
      z-index: 6;
    }
    #panel {
      width: min(640px, calc(100vw - 28px));
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding: 16px 16px 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
    }
    #panel h1 { margin: 0 0 8px; font-size: 18px; }
    #panel p { margin: 8px 0; opacity: .92; }
    #panel kbd { padding: 2px 6px; border-radius: 6px; background: rgba(255,255,255,.12); border: 1px solid rgba(255,255,255,.14); font-size: 12px; }
    #btn { margin-top: 10px; display:inline-flex; gap:10px; align-items:center; padding: 10px 12px; border-radius: 12px; background: rgba(255,255,255,.12); border: 1px solid rgba(255,255,255,.16); cursor: pointer; user-select: none; }
    #btn:hover { background: rgba(255,255,255,.16); }
    #small { font-size: 12px; opacity: .82; margin-top: 10px; }
    #errBox {
      margin-top: 10px;
      font-size: 12px;
      color: #ffd3d3;
      background: rgba(255,90,90,.12);
      border: 1px solid rgba(255,90,90,.22);
      padding: 8px 10px;
      border-radius: 12px;
      display:none;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div id="hud"></div>
  <div id="center"><div id="crosshair"></div></div>

  <div id="overlay">
    <div id="panel">
      <h1>FPS Athletic（3D一人称）</h1>
      <p><b>BUILD: 20260118_4</b></p>
      <p>操作：<kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> 移動 / <kbd>Space</kbd> ジャンプ / <kbd>Shift</kbd> ダッシュ / <kbd>R</kbd> リスタート</p>
      <p>チェックポイント：<b>床の板</b>を踏むと更新</p>
      <div id="btn">▶ クリックして開始</div>
      <div id="small">※ ESCで解除。ゴールで次ステージへ。</div>
      <div id="errBox"></div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  (() => {
    const BUILD = "20260118_4";
    const hud = document.getElementById("hud");
    const overlay = document.getElementById("overlay");
    const btn = document.getElementById("btn");
    const errBox = document.getElementById("errBox");

    let running = true;

    function fatal(msg){
      errBox.style.display = "block";
      errBox.textContent = msg;
      overlay.style.display = "flex";
      try { document.exitPointerLock?.(); } catch {}
      running = false;
      console.error(msg);
    }

    window.addEventListener("error", (e)=> fatal("クラッシュしました:\n" + (e.message || e.error || "unknown")));
    window.addEventListener("unhandledrejection", (e)=> fatal("クラッシュしました(Promise):\n" + (e.reason?.message || e.reason || "unknown")));

    if (!window.THREE) { fatal("Three.js が読み込めていません（unpkgブロック疑い）。"); return; }

    // Renderer / Scene
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(2, devicePixelRatio||1));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x08101a, 12, 180);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 900);

    // FPS rig
    const rig = new THREE.Object3D(); scene.add(rig);
    const pitchObj = new THREE.Object3D(); rig.add(pitchObj); pitchObj.add(camera);

    const PLAYER_HEIGHT = 1.75;
    const PLAYER_RADIUS = 0.35;
    camera.position.set(0, PLAYER_HEIGHT, 0);

    let yaw=0, pitch=0;
    const PITCH_LIMIT = Math.PI*0.49;

    let locked = false;
    function lockPointer(){ renderer.domElement.requestPointerLock(); }
    document.addEventListener("pointerlockchange", () => {
      locked = (document.pointerLockElement === renderer.domElement);
      overlay.style.display = locked ? "none" : "flex";
    });
    btn.addEventListener("click", lockPointer);
    overlay.addEventListener("click", (e)=>{ if(e.target===overlay) lockPointer(); });

    document.addEventListener("mousemove", (e)=>{
      if(!locked) return;
      const sens=0.0022;
      yaw   -= e.movementX*sens;
      pitch -= e.movementY*sens;
      pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      rig.rotation.y = yaw;
      pitchObj.rotation.x = pitch;
    });

    // Lights
    scene.add(new THREE.HemisphereLight(0x9fd0ff, 0x071018, 0.85));
    const dir = new THREE.DirectionalLight(0xffffff, 0.95);
    dir.position.set(10, 18, 6);
    scene.add(dir);

    // Procedural textures
    function makeCanvasTexture({w=256,h=256, base="#2a2f34", accent="#161a1e", speck="#4a515a", lines=false}){
      const c = document.createElement("canvas");
      c.width=w; c.height=h;
      const g=c.getContext("2d");
      g.fillStyle=base; g.fillRect(0,0,w,h);
      for(let i=0;i<9000;i++){
        const x=(Math.random()*w)|0, y=(Math.random()*h)|0;
        g.fillStyle=`rgba(255,255,255,${Math.random()*0.12})`;
        g.fillRect(x,y,1,1);
      }
      for(let i=0;i<220;i++){
        const x=Math.random()*w, y=Math.random()*h, r=6+Math.random()*28;
        g.beginPath();
        g.fillStyle = (Math.random()<0.5? accent : speck);
        g.globalAlpha = 0.25 + Math.random()*0.25;
        g.arc(x,y,r,0,Math.PI*2);
        g.fill();
      }
      g.globalAlpha=1;
      if(lines){
        g.strokeStyle="rgba(0,0,0,0.18)";
        for(let i=0;i<26;i++){
          g.lineWidth=1+Math.random()*2;
          g.beginPath();
          const y0=(i/26)*h + (Math.random()*8-4);
          g.moveTo(0,y0);
          for(let x=0;x<=w;x+=16) g.lineTo(x, y0 + Math.sin((x/50)+i)*3);
          g.stroke();
        }
      }
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.anisotropy = 4;
      return tex;
    }

    const texGround = makeCanvasTexture({ base:"#2b3b22", accent:"#1d2417", speck:"#4f6a3a" }); texGround.repeat.set(6,6);
    const texRock   = makeCanvasTexture({ base:"#2a2f34", accent:"#161a1e", speck:"#4a515a" }); texRock.repeat.set(4,4);
    const texMoss   = makeCanvasTexture({ base:"#2b4026", accent:"#162314", speck:"#557a43" }); texMoss.repeat.set(3,3);
    const texWood   = makeCanvasTexture({ base:"#3b2a1d", accent:"#24180f", speck:"#6b4a2c", lines:true }); texWood.repeat.set(2,2);

    function mat(map){ return new THREE.MeshStandardMaterial({ color:0xffffff, map, roughness:0.98, metalness:0.0 }); }
    const mats = {
      ground: mat(texGround),
      rock:   mat(texRock),
      moss:   mat(texMoss),
      wood:   mat(texWood),
      mover:  new THREE.MeshStandardMaterial({ color:0x7adcff, roughness:0.6, metalness:0.05, transparent:true, opacity:0.28 }),
      hazard: new THREE.MeshStandardMaterial({ color:0xff5a5a, roughness:0.65, metalness:0.0, transparent:true, opacity:0.35 }),
      cpPlate: new THREE.MeshStandardMaterial({ color:0x78ffa0, roughness:0.6, metalness:0.0, transparent:true, opacity:0.55 }),
      cpPlateOn: new THREE.MeshStandardMaterial({ color:0x78ffa0, roughness:0.6, metalness:0.0, transparent:true, opacity:0.95 }),
      goal:   new THREE.MeshStandardMaterial({ color:0xffdc78, roughness:0.7, metalness:0.0, transparent:true, opacity:0.28 }),
    };

    // World
    const world = { solids:[], hazards:[], checkpoints:[], movers:[], goal:null, deco:[], stage:0, stages:2 };

    function addBox(pos, size, mat, list){
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(size.x,size.y,size.z), mat);
      mesh.position.copy(pos);
      scene.add(mesh);
      const obj = { mesh, box3: new THREE.Box3().setFromObject(mesh), size: size.clone() };
      list.push(obj);
      return obj;
    }
    function updateBox3(obj){ obj.box3.setFromObject(obj.mesh); }

    function addTree(x,z, baseY=0){
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.24,2.4,8), mats.wood);
      trunk.position.set(x, baseY+1.2, z);
      const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.2,2.8,10), mats.moss);
      leaves.position.set(x, baseY+3.2, z);
      scene.add(trunk); scene.add(leaves);
      world.deco.push(trunk, leaves);
    }
    function addRockDeco(x,z, baseY=0){
      const r = new THREE.Mesh(new THREE.DodecahedronGeometry(0.8+Math.random()*0.9), mats.rock);
      r.position.set(x, baseY+0.8, z);
      r.rotation.set(Math.random(),Math.random(),Math.random());
      scene.add(r);
      world.deco.push(r);
    }

    function clearStage(){
      for(const a of [world.solids, world.hazards, world.checkpoints]){
        for(const o of a){ scene.remove(o.mesh); }
        a.length = 0;
      }
      for(const m of world.movers){ scene.remove(m.obj.mesh); }
      world.movers.length = 0;
      if(world.goal){ scene.remove(world.goal.mesh); world.goal=null; }
      for(const d of world.deco){ scene.remove(d); }
      world.deco.length = 0;
    }

    // Physics + input
    const keys = new Set();
    addEventListener("keydown", (e)=> keys.add(e.code));
    addEventListener("keyup", (e)=> keys.delete(e.code));
    const want = (c)=> keys.has(c);
    const wantRun = ()=> want("ShiftLeft") || want("ShiftRight");

    let velocity = new THREE.Vector3(0,0,0);
    let onGround = false;
    let deaths=0;
    let finished=false;
    let startTime=performance.now();
    let finishTime=0;

    const GRAVITY=18.5, WALK_SPEED=6.2, RUN_SPEED=9.2, AIR_CONTROL=0.45, JUMP_V=7.6, FRICTION=12.0;
    let jumpWasDown=false;

    let spawnDefault = new THREE.Vector3(0,0.02,6);
    let currentSpawn = spawnDefault.clone();

    function setFacingForward(){
      yaw=0; pitch=0; rig.rotation.y=yaw; pitchObj.rotation.x=pitch;
    }

    function playerAABB(posFeet){
      return new THREE.Box3(
        new THREE.Vector3(posFeet.x-PLAYER_RADIUS, posFeet.y, posFeet.z-PLAYER_RADIUS),
        new THREE.Vector3(posFeet.x+PLAYER_RADIUS, posFeet.y+PLAYER_HEIGHT, posFeet.z+PLAYER_RADIUS)
      );
    }

    // ---- Axis-separated collision helpers (prevents wall climb) ----
    function resolveAxisX(pos){
      const pBox = playerAABB(pos);
      for(const s of world.solids){
        if(!pBox.intersectsBox(s.box3)) continue;
        // push out along X only
        const leftPen  = pBox.max.x - s.box3.min.x; // penetration if player is left
        const rightPen = s.box3.max.x - pBox.min.x; // penetration if player is right
        const pCenterX = (pBox.min.x + pBox.max.x)*0.5;
        const sCenterX = (s.box3.min.x + s.box3.max.x)*0.5;
        if(pCenterX < sCenterX) pos.x -= leftPen;
        else pos.x += rightPen;
        velocity.x = 0;
        pBox.setFromCenterAndSize(
          new THREE.Vector3(pos.x, pos.y + PLAYER_HEIGHT*0.5, pos.z),
          new THREE.Vector3(PLAYER_RADIUS*2, PLAYER_HEIGHT, PLAYER_RADIUS*2)
        );
      }
    }

    function resolveAxisZ(pos){
      const pBox = playerAABB(pos);
      for(const s of world.solids){
        if(!pBox.intersectsBox(s.box3)) continue;
        const frontPen = pBox.max.z - s.box3.min.z;
        const backPen  = s.box3.max.z - pBox.min.z;
        const pCenterZ = (pBox.min.z + pBox.max.z)*0.5;
        const sCenterZ = (s.box3.min.z + s.box3.max.z)*0.5;
        if(pCenterZ < sCenterZ) pos.z -= frontPen;
        else pos.z += backPen;
        velocity.z = 0;
        pBox.setFromCenterAndSize(
          new THREE.Vector3(pos.x, pos.y + PLAYER_HEIGHT*0.5, pos.z),
          new THREE.Vector3(PLAYER_RADIUS*2, PLAYER_HEIGHT, PLAYER_RADIUS*2)
        );
      }
    }

    function resolveAxisY(pos){
      onGround = false;
      const pBox = playerAABB(pos);
      for(const s of world.solids){
        if(!pBox.intersectsBox(s.box3)) continue;
        const downPen = pBox.max.y - s.box3.min.y; // player below top? careful
        const upPen   = s.box3.max.y - pBox.min.y;
        const vy = velocity.y;

        // If falling, treat as landing on top
        if(vy <= 0){
          // Move feet so player's max.y sits on s.min.y? Actually landing means player bottom hits s.max.y.
          // Player bottom is pBox.min.y. If it penetrates into solid, push up so bottom equals solid top.
          pos.y = s.box3.max.y;
          onGround = true;
          velocity.y = 0;
        } else {
          // Hitting ceiling: push down so top equals solid bottom
          pos.y = s.box3.min.y - PLAYER_HEIGHT;
          velocity.y = 0;
        }

        pBox.min.set(pos.x-PLAYER_RADIUS, pos.y, pos.z-PLAYER_RADIUS);
        pBox.max.set(pos.x+PLAYER_RADIUS, pos.y+PLAYER_HEIGHT, pos.z+PLAYER_RADIUS);
      }
    }

    function respawn(countDeath=true){
      if(countDeath) deaths++;
      velocity.set(0,0,0);
      rig.position.copy(currentSpawn);
      onGround=false;
    }

    function restart(keepDeaths=true){
      finished=false;
      startTime=performance.now();
      finishTime=0;
      for(const cp of world.checkpoints){
        cp.hit=false;
        cp.mesh.material = mats.cpPlate;
      }
      currentSpawn.copy(spawnDefault);
      rig.position.copy(spawnDefault);
      velocity.set(0,0,0);
      setFacingForward();
    }

    // R is always on
    addEventListener("keydown", (e)=>{ if(e.code==="KeyR") restart(true); });

    function markCheckpoint(cp){
      cp.hit=true;
      cp.mesh.material = mats.cpPlateOn;
      currentSpawn.copy(cp.spawn);
    }

    function buildCheckpointPlate(center, spawnFacingForward=true){
      // Thin plate you step on
      const plateSize = new THREE.Vector3(2.2, 0.18, 2.2);
      const plate = addBox(center, plateSize, mats.cpPlate, world.checkpoints);
      plate.hit = false;
      plate.spawn = new THREE.Vector3(center.x, center.y + 0.02, center.z + 1.8); // little forward
      plate.spawnFacingForward = spawnFacingForward;
      return plate;
    }

    function nextStage(){
      world.stage = (world.stage + 1) % world.stages;
      buildStage(world.stage);
      restart(true);
    }

    // Movers
    function updateMovers(dt){
      for(const m of world.movers){
        m.prev.copy(m.obj.mesh.position);
        m.t += dt*m.spd;
        const p = m.base.clone();
        const s = Math.sin(m.t)*m.amp;
        if(m.axis==="y") p.y += s;
        if(m.axis==="x") p.x += s;
        if(m.axis==="z") p.z += s;
        m.obj.mesh.position.copy(p);
        updateBox3(m.obj);
      }
    }

    // Stage builder (same as before but CPs are plates on top of platforms)
    function buildStage(idx){
      clearStage();
      world.stage = idx;

      function addRock(x,z, baseY=0){ addRockDeco(x,z,baseY); }

      if(idx===0){
        scene.fog.color.set(0x08101a); scene.fog.far=190;
        spawnDefault = new THREE.Vector3(0,0.02,7);

        addBox(new THREE.Vector3(0,-0.5,0), new THREE.Vector3(28,1,28), mats.ground, world.solids);

        // Start platform in front
        const startPlat = addBox(new THREE.Vector3(0,0.6,2), new THREE.Vector3(6,1,4), mats.moss, world.solids);

        addBox(new THREE.Vector3(0,1.8,-6),  new THREE.Vector3(4,1,4), mats.rock, world.solids);
        addBox(new THREE.Vector3(0,3.0,-14), new THREE.Vector3(4,1,4), mats.rock, world.solids);
        addBox(new THREE.Vector3(2.2,4.2,-22),new THREE.Vector3(5,1,5), mats.moss, world.solids);

        addBox(new THREE.Vector3(2.2,5.1,-30),new THREE.Vector3(7,0.6,1.2), mats.wood, world.solids);
        addBox(new THREE.Vector3(2.2,6.0,-40),new THREE.Vector3(7,0.6,1.2), mats.wood, world.solids);

        const bigLanding = addBox(new THREE.Vector3(0.5,5.2,-52),new THREE.Vector3(12,1,10), mats.rock, world.solids);

        // movers
        const m1 = addBox(new THREE.Vector3(-3.0,5.0,-66), new THREE.Vector3(4.5,0.7,4.5), mats.mover, world.solids);
        world.movers.push({ obj:m1, base:m1.mesh.position.clone(), axis:"y", amp:2.4, spd:1.1, t:0, prev:m1.mesh.position.clone() });

        const m2 = addBox(new THREE.Vector3(3.5,6.0,-78), new THREE.Vector3(6.0,0.7,3.0), mats.mover, world.solids);
        world.movers.push({ obj:m2, base:m2.mesh.position.clone(), axis:"x", amp:3.2, spd:0.9, t:1.3, prev:m2.mesh.position.clone() });

        const final1 = addBox(new THREE.Vector3(0,7.4,-92), new THREE.Vector3(6,1,6), mats.moss, world.solids);
        const final2 = addBox(new THREE.Vector3(0,9.2,-108),new THREE.Vector3(5,1,5), mats.rock, world.solids);

        // hazards
        addBox(new THREE.Vector3(0,0.15,2),   new THREE.Vector3(3.2,0.25,3.2), mats.hazard, world.hazards);
        addBox(new THREE.Vector3(2.2,4.85,-24),new THREE.Vector3(3.2,0.25,3.2), mats.hazard, world.hazards);
        addBox(new THREE.Vector3(0.5,4.7,-52), new THREE.Vector3(3.0,0.25,3.0), mats.hazard, world.hazards);

        // Side guide walls (now unclimbable due to axis collision)
        addBox(new THREE.Vector3(7.5,3.0,-58),  new THREE.Vector3(1.2,8,160), mats.rock, world.solids);
        addBox(new THREE.Vector3(-7.5,3.0,-58), new THREE.Vector3(1.2,8,160), mats.rock, world.solids);

        // Checkpoint plates ON TOP of platforms (no floating poles)
        // Platform top Y = centerY + sizeY/2. Plate center sits slightly above top.
        const startTopY = 0.6 + 1/2;
        buildCheckpointPlate(new THREE.Vector3(0, startTopY + 0.09, 2));

        const landTopY = 5.2 + 1/2;
        buildCheckpointPlate(new THREE.Vector3(0.5, landTopY + 0.09, -52));

        const finTopY = 9.2 + 1/2;
        buildCheckpointPlate(new THREE.Vector3(0, finTopY + 0.09, -108));

        // Goal
        world.goal = addBox(new THREE.Vector3(0,10.0,-122), new THREE.Vector3(4,3,4), mats.goal, []);

        // Deco
        for(let i=0;i<22;i++) addTree(-11+Math.random()*22, 10-Math.random()*140, 0);
        for(let i=0;i<18;i++) addRock(-12+Math.random()*24, 8-Math.random()*140, 0);

      } else {
        scene.fog.color.set(0x05080e); scene.fog.far=150;
        spawnDefault = new THREE.Vector3(0,0.02,7);

        addBox(new THREE.Vector3(0,-0.5,0), new THREE.Vector3(30,1,30), mats.rock, world.solids);
        addBox(new THREE.Vector3(0,0.6,2),  new THREE.Vector3(6,1,4), mats.rock, world.solids);

        // corridor
        addBox(new THREE.Vector3(8.5,4.0,-70),  new THREE.Vector3(2.0,10,220), mats.rock, world.solids);
        addBox(new THREE.Vector3(-8.5,4.0,-70), new THREE.Vector3(2.0,10,220), mats.rock, world.solids);
        addBox(new THREE.Vector3(0,12.0,-60),   new THREE.Vector3(18,1.8,120), mats.rock, world.solids);

        const s1 = addBox(new THREE.Vector3(-1.5,1.6,-10), new THREE.Vector3(3.6,1,3.6), mats.rock, world.solids);
        const s2 = addBox(new THREE.Vector3( 2.0,2.6,-22), new THREE.Vector3(3.6,1,3.6), mats.rock, world.solids);
        const s3 = addBox(new THREE.Vector3(-2.0,3.6,-34), new THREE.Vector3(3.6,1,3.6), mats.rock, world.solids);

        for(let i=0;i<8;i++){
          addBox(new THREE.Vector3((i%2?2.5:-2.5), 1.5+i*0.7, -46 - i*7), new THREE.Vector3(2.2, 3+i*0.35, 2.2), mats.rock, world.solids);
        }

        const mv = addBox(new THREE.Vector3(0,7.0,-112), new THREE.Vector3(8.0,0.7,3.0), mats.mover, world.solids);
        world.movers.push({ obj:mv, base:mv.mesh.position.clone(), axis:"x", amp:5.0, spd:0.85, t:0.4, prev:mv.mesh.position.clone() });

        const fin = addBox(new THREE.Vector3(0,8.0,-136), new THREE.Vector3(8,1,8), mats.rock, world.solids);

        addBox(new THREE.Vector3(0,0.15,2),   new THREE.Vector3(3.0,0.25,3.0), mats.hazard, world.hazards);
        addBox(new THREE.Vector3(0,6.6,-98),  new THREE.Vector3(6.0,0.25,2.2), mats.hazard, world.hazards);

        // Checkpoint plates
        const startTopY = 0.6 + 1/2;
        buildCheckpointPlate(new THREE.Vector3(0, startTopY + 0.09, 2));

        const midTopY = 3.6 + 1/2;
        buildCheckpointPlate(new THREE.Vector3(-2.0, midTopY + 0.09, -34));

        const finTopY = 8.0 + 1/2;
        buildCheckpointPlate(new THREE.Vector3(0, finTopY + 0.09, -136));

        world.goal = addBox(new THREE.Vector3(0,9.5,-160), new THREE.Vector3(4,3,4), mats.goal, []);

        for(let i=0;i<28;i++) addRockDeco(-7+Math.random()*14, 10-Math.random()*180, 0);
      }

      currentSpawn.copy(spawnDefault);
      rig.position.copy(spawnDefault);
      setFacingForward();

      // update box3
      for(const s of world.solids) updateBox3(s);
      for(const h of world.hazards) updateBox3(h);
      for(const cp of world.checkpoints) updateBox3(cp);
      if(world.goal) updateBox3(world.goal);
    }

    // main step (axis-separated)
    function step(dt){
      updateMovers(dt);
      if(finished) return;

      const wasGround = onGround;

      // move direction
      const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw).normalize();
      const right   = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw).normalize();

      let wish = new THREE.Vector3();
      if(want("KeyW")) wish.add(forward);
      if(want("KeyS")) wish.sub(forward);
      if(want("KeyD")) wish.add(right);
      if(want("KeyA")) wish.sub(right);
      if(wish.lengthSq()>0) wish.normalize();

      const speed = wantRun()? RUN_SPEED : WALK_SPEED;
      const targetV = wish.multiplyScalar(speed);

      const accel = wasGround ? 16.0 : 10.0;
      const control = wasGround ? 1.0 : AIR_CONTROL;

      velocity.x += (targetV.x - velocity.x) * Math.min(1, accel*dt*control);
      velocity.z += (targetV.z - velocity.z) * Math.min(1, accel*dt*control);

      if(wish.lengthSq()===0 && wasGround){
        const damp = Math.exp(-FRICTION*dt);
        velocity.x *= damp; velocity.z *= damp;
      }

      velocity.y -= GRAVITY*dt;

      // jump edge trigger
      const jumpDown = want("Space");
      const jumpPressed = jumpDown && !jumpWasDown;
      jumpWasDown = jumpDown;
      if(jumpPressed && wasGround) velocity.y = JUMP_V;

      const p = rig.position;

      // Integrate by axis: X -> Z -> Y
      p.x += velocity.x * dt;
      resolveAxisX(p);

      p.z += velocity.z * dt;
      resolveAxisZ(p);

      p.y += velocity.y * dt;
      resolveAxisY(p);

      // mover carry if onGround
      if(onGround){
        const below = p.clone(); below.y -= 0.06;
        const belowBox = playerAABB(below);
        for(const m of world.movers){
          if(belowBox.intersectsBox(m.obj.box3)){
            const delta = m.obj.mesh.position.clone().sub(m.prev);
            p.add(delta);
            break;
          }
        }
      }

      const pBoxNow = playerAABB(p);

      // hazards
      for(const hz of world.hazards){
        if(pBoxNow.intersectsBox(hz.box3)){ respawn(true); return; }
      }

      // checkpoint plates: must be "stepping on" (feet near top)
      for(const cp of world.checkpoints){
        if(cp.hit) continue;
        if(!pBoxNow.intersectsBox(cp.box3)) continue;

        const plateTop = cp.box3.max.y;
        const feetY = p.y;

        // Feet are on/very near top of plate
        if(Math.abs(feetY - plateTop) < 0.12 && onGround){
          markCheckpoint(cp);
        }
      }

      // goal
      if(world.goal){
        updateBox3(world.goal);
        if(pBoxNow.intersectsBox(world.goal.box3)){
          finished=true;
          finishTime=(performance.now()-startTime)/1000;
          setTimeout(nextStage, 650);
        }
      }

      if(p.y < -40) respawn(true);
    }

    // stage init
    function restartTimersOnly(){
      finished=false;
      startTime=performance.now();
      finishTime=0;
    }

    buildStage(0);
    restart(true);
    restartTimersOnly();

    // loop
    let last = performance.now();
    function loop(now){
      if(!running) return;
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      try{
        if(locked) step(dt);
      }catch(e){
        fatal("クラッシュしました:\n" + (e?.stack || e?.message || String(e)));
        return;
      }

      const t = finished ? finishTime : (now-startTime)/1000;
      hud.textContent = `BUILD:${BUILD}  Stage:${world.stage+1}/${world.stages}  Time:${t.toFixed(2)}  Death:${deaths}   (R=restart)`;

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    addEventListener("resize", ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  })();
  </script>
</body>
</html>
