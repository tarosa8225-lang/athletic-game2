<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini FPS (HTML Canvas)</title>
  <style>
    html, body { margin: 0; height: 100%; background:#0b0f14; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    .hud {
      position: fixed; inset: 0; pointer-events:none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
      color:#eaf2ff;
    }
    .topLeft { position:absolute; left:16px; top:14px; font-size:14px; opacity:0.95; }
    .topLeft .line { margin: 2px 0; }
    .center { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); opacity:0.9; }
    .crosshair {
      width: 16px; height:16px; position:relative;
      filter: drop-shadow(0 0 2px rgba(0,0,0,0.8));
    }
    .crosshair:before, .crosshair:after{
      content:""; position:absolute; left:50%; top:50%;
      background:#eaf2ff; transform:translate(-50%,-50%);
    }
    .crosshair:before { width: 16px; height:2px; }
    .crosshair:after { width: 2px; height:16px; }
    .hint {
      position:absolute; left:50%; top:60%;
      transform:translate(-50%,-50%);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px 12px; border-radius: 10px;
      font-size: 14px; line-height:1.45; text-align:center;
      max-width: 560px;
    }
    .hint b{ color:#fff; }
    .bottomRight { position:absolute; right:16px; bottom:14px; font-size:14px; opacity:0.95; text-align:right;}
    .bar {
      height: 8px; width: 220px; background: rgba(255,255,255,0.10);
      border-radius: 999px; overflow:hidden; border:1px solid rgba(255,255,255,0.10);
    }
    .bar > div { height:100%; width:50%; background: rgba(110,200,255,0.95); }
    .small { font-size: 12px; opacity:0.8; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="topLeft">
      <div class="line"><b>Mini FPS</b>（HTML/Canvas 擬似3D）</div>
      <div class="line small">クリックで開始 / ESCで解除</div>
      <div class="line small">WASD 移動・Shift 走る・左クリック 射撃・R リロード</div>
    </div>

    <div class="center">
      <div class="crosshair"></div>
      <div class="hint" id="hint">
        画面を<b>クリック</b>して開始（マウス視点が有効になる）<br/>
        敵に照準を合わせて撃ってね
      </div>
    </div>

    <div class="bottomRight">
      <div id="ammo"></div>
      <div class="bar"><div id="hpbar"></div></div>
      <div class="small" id="status"></div>
    </div>
  </div>

<script>
(() => {
  // ========= Canvas setup =========
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const hint = document.getElementById("hint");
  const ammoEl = document.getElementById("ammo");
  const hpbarEl = document.getElementById("hpbar");
  const statusEl = document.getElementById("status");

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  addEventListener("resize", resize);
  resize();

  // ========= Simple world =========
  // "擬似3D": プレイヤーの視線方向に対して、敵を2D投影して描く（レイキャストは角度差で判定）
  const TAU = Math.PI * 2;

  const player = {
    x: 0, y: 0,         // 2D平面上
    yaw: 0,             // 視点（角度）
    speed: 5.4,
    sprintMul: 1.5,
    hp: 100,
    maxHp: 100,
  };

  const gun = {
    magSize: 24,
    ammo: 24,
    reloadTime: 1.1,
    reloading: false,
    fireRate: 10,          // shots per sec
    lastShot: 0,
    damage: 34,
    spread: 0.008,         // ほんの少し拡散
    range: 60,
  };

  // 敵（円として当たり判定）
  let enemies = [];
  function spawnEnemy() {
    // プレイヤーの前方ランダムにスポーン
    const ang = player.yaw + (Math.random()*0.9 - 0.45);
    const dist = 10 + Math.random()*40;
    enemies.push({
      x: player.x + Math.cos(ang) * dist,
      y: player.y + Math.sin(ang) * dist,
      r: 0.55,
      hp: 100,
      maxHp: 100,
      alive: true,
    });
  }
  for (let i=0;i<10;i++) spawnEnemy();

  // ========= Input =========
  const keys = new Set();
  addEventListener("keydown", (e) => {
    keys.add(e.code);
    if (e.code === "KeyR") startReload();
  });
  addEventListener("keyup", (e) => keys.delete(e.code));

  let mouseDown = false;
  addEventListener("mousedown", (e) => { if (e.button === 0) mouseDown = true; });
  addEventListener("mouseup", (e) => { if (e.button === 0) mouseDown = false; });

  // Pointer Lock
  function isLocked() {
    return document.pointerLockElement === canvas;
  }
  canvas.addEventListener("click", async () => {
    if (!isLocked()) {
      canvas.requestPointerLock?.();
    }
  });

  document.addEventListener("pointerlockchange", () => {
    hint.style.display = isLocked() ? "none" : "block";
  });

  document.addEventListener("mousemove", (e) => {
    if (!isLocked()) return;
    const sens = 0.0022;
    player.yaw = (player.yaw + e.movementX * sens) % TAU;
    if (player.yaw < 0) player.yaw += TAU;
  });

  // ========= Helpers =========
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function angDiff(a, b) {
    let d = a - b;
    while (d > Math.PI) d -= TAU;
    while (d < -Math.PI) d += TAU;
    return d;
  }
  function dist2(ax, ay, bx, by){
    const dx = ax-bx, dy = ay-by;
    return dx*dx + dy*dy;
  }

  // ========= Reload =========
  function startReload() {
    if (gun.reloading) return;
    if (gun.ammo === gun.magSize) return;
    gun.reloading = true;
    statusEl.textContent = "Reloading...";
    setTimeout(() => {
      gun.ammo = gun.magSize;
      gun.reloading = false;
      statusEl.textContent = "";
    }, gun.reloadTime * 1000);
  }

  // ========= Shooting (hitscan) =========
  function tryShoot(now) {
    if (!isLocked()) return;
    if (gun.reloading) return;
    if (!mouseDown) return;
    const minDt = 1 / gun.fireRate;
    if (now - gun.lastShot < minDt) return;

    if (gun.ammo <= 0) {
      startReload();
      return;
    }

    gun.lastShot = now;
    gun.ammo--;

    // 目標選択：視線中心に近い敵を探し、距離と角度でヒット判定
    // "レイ": player.yaw + spread
    const shotYaw = player.yaw + (Math.random()*2 - 1) * gun.spread;

    let best = null;
    for (const e of enemies) {
      if (!e.alive) continue;
      const dx = e.x - player.x;
      const dy = e.y - player.y;
      const d = Math.sqrt(dx*dx + dy*dy);
      if (d > gun.range) continue;

      const targetYaw = Math.atan2(dy, dx);
      const dAng = Math.abs(angDiff(targetYaw, shotYaw));

      // 敵の見かけ角（半径/距離）
      const hitAng = Math.atan2(e.r, d);
      if (dAng <= hitAng) {
        // 中心に近い（角度が小さい）+ 近い のを優先
        const score = dAng * 2 + d * 0.02;
        if (!best || score < best.score) best = { e, score, d };
      }
    }

    if (best) {
      best.e.hp -= gun.damage;
      if (best.e.hp <= 0) {
        best.e.alive = false;
        // 倒したら補充スポーン
        setTimeout(spawnEnemy, 350);
      }
    }
  }

  // ========= Movement =========
  function updateMove(dt) {
    if (!isLocked()) return;

    let vx = 0, vy = 0;
    if (keys.has("KeyW")) { vx += Math.cos(player.yaw); vy += Math.sin(player.yaw); }
    if (keys.has("KeyS")) { vx -= Math.cos(player.yaw); vy -= Math.sin(player.yaw); }
    if (keys.has("KeyA")) { vx += Math.cos(player.yaw - Math.PI/2); vy += Math.sin(player.yaw - Math.PI/2); }
    if (keys.has("KeyD")) { vx += Math.cos(player.yaw + Math.PI/2); vy += Math.sin(player.yaw + Math.PI/2); }

    const len = Math.hypot(vx, vy);
    if (len > 0.0001) { vx /= len; vy /= len; }

    const sp = player.speed * (keys.has("ShiftLeft") || keys.has("ShiftRight") ? player.sprintMul : 1);
    player.x += vx * sp * dt;
    player.y += vy * sp * dt;
  }

  // ========= Enemy simple AI =========
  function updateEnemies(dt) {
    // 近い敵はプレイヤーに寄ってくる＆近距離でダメージ（超簡易）
    for (const e of enemies) {
      if (!e.alive) continue;
      const dx = player.x - e.x;
      const dy = player.y - e.y;
      const d = Math.hypot(dx, dy);
      if (d > 0.001) {
        const chase = d < 25 ? 1.4 : 0.6;
        e.x += (dx / d) * chase * dt;
        e.y += (dy / d) * chase * dt;
      }
      if (d < 1.2) {
        player.hp -= 14 * dt; // DPS
      }
    }
    player.hp = clamp(player.hp, 0, player.maxHp);
  }

  // ========= Rendering (pseudo 3D) =========
  function render() {
    const W = innerWidth;
    const H = innerHeight;

    // 背景（空+地面）
    ctx.clearRect(0,0,W,H);
    // sky
    ctx.fillStyle = "#0b1626";
    ctx.fillRect(0,0,W,H*0.55);
    // ground
    ctx.fillStyle = "#0a0f14";
    ctx.fillRect(0,H*0.55,W,H*0.45);

    // 地面のライン（疑似遠近）
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = "#88a1bf";
    for (let i=1;i<=18;i++){
      const t = i/18;
      const y = H*0.55 + t*t*(H*0.45);
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(W,y);
      ctx.stroke();
    }
    ctx.restore();

    // ミニマップっぽい（左下）
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.fillRect(14, H-144, 130, 130);
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.strokeRect(14, H-144, 130, 130);

    const mmx = 14+65, mmy = H-144+65;
    ctx.fillStyle = "rgba(110,200,255,0.95)";
    ctx.beginPath(); ctx.arc(mmx, mmy, 3.5, 0, TAU); ctx.fill();
    // view direction
    ctx.strokeStyle = "rgba(110,200,255,0.95)";
    ctx.beginPath();
    ctx.moveTo(mmx, mmy);
    ctx.lineTo(mmx + Math.cos(player.yaw)*18, mmy + Math.sin(player.yaw)*18);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,120,120,0.9)";
    for (const e of enemies) {
      if (!e.alive) continue;
      const dx = e.x - player.x, dy = e.y - player.y;
      const sx = mmx + dx*2.3, sy = mmy + dy*2.3;
      if (sx < 14 || sx > 14+130 || sy < H-144 || sy > H-144+130) continue;
      ctx.beginPath(); ctx.arc(sx, sy, 3, 0, TAU); ctx.fill();
    }
    ctx.restore();

    // 敵を描く（視界内のものを距離順に）
    const fov = 75 * Math.PI/180;
    const half = fov/2;

    const visibles = [];
    for (const e of enemies) {
      if (!e.alive) continue;
      const dx = e.x - player.x;
      const dy = e.y - player.y;
      const d = Math.hypot(dx, dy);
      const yawTo = Math.atan2(dy, dx);
      const a = angDiff(yawTo, player.yaw);
      if (Math.abs(a) <= half + 0.25 && d < 70) {
        visibles.push({ e, d, a });
      }
    }
    visibles.sort((a,b)=> b.d - a.d); // far first so near draws over

    for (const v of visibles) {
      const { e, d, a } = v;
      const xNorm = (a / half) * 0.5;         // -0.5..0.5-ish
      const x = W * (0.5 + xNorm);

      // size by distance
      const size = clamp(900 / (d + 0.1), 16, 240);
      const y = H*0.55 - size*0.35;

      // body
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = "rgba(255,120,120,0.92)";
      ctx.beginPath();
      ctx.roundRect(x - size*0.35, y - size*0.15, size*0.7, size*0.9, 10);
      ctx.fill();

      // health bar
      const hpw = size*0.75;
      const hpp = clamp(e.hp / e.maxHp, 0, 1);
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      ctx.fillRect(x - hpw/2, y - 14, hpw, 8);
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillRect(x - hpw/2, y - 14, hpw*hpp, 8);

      // outline
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.strokeRect(x - size*0.35, y - size*0.15, size*0.7, size*0.9);
      ctx.restore();
    }

    // HUD
    ammoEl.textContent = `Ammo: ${gun.ammo}/${gun.magSize}`;
    hpbarEl.style.width = `${(player.hp/player.maxHp)*100}%`;
    if (player.hp <= 0) {
      statusEl.textContent = "You are down.（リロードで復帰…じゃなくてF5でリトライw）";
    }
  }

  // ========= Polyfill for roundRect (older browsers) =========
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  // ========= Main loop =========
  let last = performance.now() / 1000;
  function loop() {
    const now = performance.now() / 1000;
    const dt = clamp(now - last, 0, 0.05);
    last = now;

    if (player.hp > 0) {
      updateMove(dt);
      updateEnemies(dt);
      tryShoot(now);
    }

    render();
    requestAnimationFrame(loop);
  }
  loop();

})();
</script>
</body>
</html>
